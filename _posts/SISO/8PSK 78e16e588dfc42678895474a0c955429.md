# 8PSK

Created: 2022년 12월 23일 오후 2:43
Created By: 응애
Last Edited By: 응애
Last Edited Time: 2022년 12월 23일 오후 3:40

# 8PSK (8 Phase Shift Keying)

```python
import numpy as np
import math
from random import randrange
from math import pi as PI
```

```python
Num_Bit = 3
BER = []
BitPerNoiseDB_iter = range(0,15)

for BitPerNoiseDB in BitPerNoiseDB_iter:
  SymbolPerNoiseRATIO = Num_Bit*10**(BitPerNoiseDB/10)
  AWGN_sigma = math.sqrt(1/(2*SymbolPerNoiseRATIO))
  
  Error_Count = 0
  Total_Error_Count = 0
  Bit_Count = 0

  while Total_Error_Count < 100:

    Information_Generator = np.empty(Num_Bit, dtype='int')
    Bit = np.empty(Num_Bit, dtype='int')
 
    for generator in range(0, Num_Bit):
      Information_Generator[generator] = randrange(2)

    Detected_Signal = np.empty(Num_Bit, dtype='int')
    Detected_Array = np.empty(Num_Bit, dtype='int')
    Bit = Information_Generator
  

    if (Bit[0] == 0 and Bit[1] == 0 and Bit[2] == 0):
      symbol = complex(math.cos(PI/8), math.sin(PI/8))

    elif (Bit[0] == 0 and Bit[1] == 0 and Bit[2] == 1):
      symbol = complex(math.cos(3*PI/8), math.sin(3*PI/8))
    
    elif (Bit[0] == 0 and Bit[1] == 1 and Bit[2] == 1):
      symbol = complex(math.cos(5*PI/8), math.sin(5*PI/8))

    elif (Bit[0] == 0 and Bit[1] == 1 and Bit[2] == 0):
      symbol = complex(math.cos(7*PI/8), math.sin(7*PI/8))

    elif (Bit[0] == 1 and Bit[1] == 1 and Bit[2] == 0):
      symbol = complex(math.cos(-7*PI/8), math.sin(-7*PI/8))

    elif (Bit[0] == 1 and Bit[1] == 1 and Bit[2] == 1):
      symbol = complex(math.cos(-5*PI/8), math.sin(-5*PI/8))

    elif (Bit[0] == 1 and Bit[1] == 0 and Bit[2] == 1):
      symbol = complex(math.cos(-3*PI/8), math.sin(-3*PI/8))

    elif (Bit[0] == 1 and Bit[1] == 0 and Bit[2] == 0):
      symbol = complex(math.cos(-1*PI/8), math.sin(-1*PI/8))

    

    AWGN = np.random.normal(size = (1,2))
    AWGN = complex(AWGN[0][0], AWGN[0][1]) * AWGN_sigma

    Received_Signal = symbol + AWGN
    Received_Signal_Phase = math.atan2(Received_Signal.imag, Received_Signal.real)

    if (Received_Signal_Phase >= 0) and (Received_Signal_Phase < PI/4):
      Detected_Array = 0, 0, 0

    elif (Received_Signal_Phase >= PI/4) and (Received_Signal_Phase < PI/2):
      Detected_Array = 0, 0, 1

    elif (Received_Signal_Phase >= PI/2) and (Received_Signal_Phase < 3*PI/4):
      Detected_Array = 0, 1, 1

    elif (Received_Signal_Phase >= 3*PI/4) and (Received_Signal_Phase < PI):
      Detected_Array = 0, 1, 0

    elif (Received_Signal_Phase >=- 1* PI) and (Received_Signal_Phase < -3*PI/4):
      Detected_Array = 1, 1, 0

    elif (Received_Signal_Phase >= -3*PI/4) and (Received_Signal_Phase < -PI/2):
      Detected_Array = 1, 1, 1

    elif (Received_Signal_Phase >= -PI/2) and (Received_Signal_Phase < -PI/4):
      Detected_Array = 1, 0, 1

    else: 
      Detected_Array = 1, 0, 0

    Error_Count = 0
    for index in range(0, Num_Bit):
      if Bit[index] != Detected_Array[index]:
        Error_Count += 1

    
    Total_Error_Count += Error_Count
    Bit_Count += Num_Bit

    
  BER.append(Total_Error_Count/Bit_Count)

  print("Bit_Count :", Bit_Count)
  print("Eb/N0 :{} [dB]".format(BitPerNoiseDB))
  print("에러가 발생한 bit수 :", Total_Error_Count)
  print("BER :", BER[BitPerNoiseDB] )
  print("---------------------------------")
```

![download.png](8PSK%2078e16e588dfc42678895474a0c955429/download.png)

[8PSK] BER values

[0.11947431302270012,
 0.0992063492063492,
 0.06887052341597796,
 0.06734006734006734,
 0.05555555555555555,
 0.031007751937984496,
 0.020768431983385256,
 0.012626262626262626,
 0.006025548324897566,
 0.0028580410986309983,
 0.0010296328329317764,
 0.0002607548330908313,
 7.472115931373098e-05,
 1.0198857320025865e-05,
 9.184787724722249e-07]